// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// tslint:disable:no-require-imports no-var-requires import-name no-function-expression no-any prefer-template no-console no-var-self
// Most of the source is in node_modules/vscode/lib/testrunner.js
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

const fs = require("fs-extra");

const glob = require("glob");

const istanbul = require("istanbul");

const Mocha = require("mocha");

const path = require("path");

const remapIstanbul = require('remap-istanbul');

const reactHelpers_1 = require("./datascience/reactHelpers"); // Linux: prevent a weird NPE when mocha on Linux requires the window size from the TTY.
// Since we are not running in a tty environment, we just implement the method statically.


const tty = require('tty');

if (!tty.getWindowSize) {
  tty.getWindowSize = function () {
    return [80, 75];
  };
}

let mocha = new Mocha({
  ui: 'tdd',
  useColors: true
});
let testFilesGlob = 'test';
let coverageOptions;

function configure(setupOptions, coverageOpts) {
  if (setupOptions.testFilesSuffix) {
    testFilesGlob = setupOptions.testFilesSuffix;
  }

  mocha = new Mocha(setupOptions);
  coverageOptions = coverageOpts;
}

exports.configure = configure;

function run(testsRoot, callback) {
  // Enable source map support.
  require('source-map-support').install(); // nteract/transforms-full expects to run in the browser so we have to fake
  // parts of the browser here.


  reactHelpers_1.setUpDomEnvironment(); // Check whether code coverage is enabled.

  const options = getCoverageOptions(testsRoot);

  if (options && options.enabled) {
    // Setup coverage pre-test, including post-test hook to report.
    // tslint:disable-next-line:no-use-before-declare
    const coverageRunner = new CoverageRunner(options, testsRoot, callback);
    coverageRunner.setupCoverage();
  } // Run the tests.


  glob(`**/**.${testFilesGlob}.js`, {
    ignore: ['**/**.unit.test.js', '**/**.functional.test.js'],
    cwd: testsRoot
  }, (error, files) => {
    if (error) {
      return callback(error);
    }

    try {
      files.forEach(file => mocha.addFile(path.join(testsRoot, file)));
      mocha.run(failures => callback(undefined, failures));
    } catch (error) {
      return callback(error);
    }
  });
}

exports.run = run;

function getCoverageOptions(testsRoot) {
  if (!coverageOptions) {
    return undefined;
  }

  const coverConfigPath = path.join(testsRoot, coverageOptions.coverageConfig);
  return fs.existsSync(coverConfigPath) ? JSON.parse(fs.readFileSync(coverConfigPath, 'utf8')) : undefined;
}

class CoverageRunner {
  constructor(options, testsRoot, endRunCallback) {
    this.options = options;
    this.testsRoot = testsRoot;
    this.coverageVar = `$$cov_${new Date().getTime()}$$`;
    this.sourceFiles = [];

    if (!options.relativeSourcePath) {
      endRunCallback(new Error('Error - relativeSourcePath must be defined for code coverage to work'));
    }
  }

  get coverage() {
    if (global[this.coverageVar] === undefined || Object.keys(global[this.coverageVar]).length === 0) {
      console.error('No coverage information was collected, exit without writing coverage information');
      return {};
    } else {
      return global[this.coverageVar];
    }
  }

  set coverage(value) {
    global[this.coverageVar] = value;
  }
  /**
   * Information on hooking up code coverage can be found here:
   * http://tannguyen.org/2017/04/gulp-mocha-and-istanbul/
   * http://gotwarlost.github.io/istanbul/public/apidocs/classes/HookOptions.html
   * @memberof CoverageRunner
   */


  setupCoverage() {
    const reportingDir = path.join(this.testsRoot, this.options.relativeCoverageDir);
    fs.emptyDirSync(reportingDir); // Set up Code Coverage, hooking require so that instrumented code is returned.

    this.instrumenter = new istanbul.Instrumenter({
      coverageVariable: this.coverageVar
    });
    const sourceRoot = path.join(this.testsRoot, this.options.relativeSourcePath); // Glob source files

    const srcFiles = glob.sync('**/**.js', {
      ignore: this.options.ignorePatterns,
      cwd: sourceRoot
    }); // Create a match function - taken from the run-with-cover.js in istanbul.

    const decache = require('decache');

    const fileMap = new Set();
    srcFiles.map(file => path.join(sourceRoot, file)).forEach(fullPath => {
      fileMap.add(fullPath); // On Windows, extension is loaded pre-test hooks and this mean we lose
      // our chance to hook the Require call. In order to instrument the code
      // we have to decache the JS file so on next load it gets instrumented.
      // This doesn't impact tests, but is a concern if we had some integration
      // tests that relied on VSCode accessing our module since there could be
      // some shared global state that we lose.

      decache(fullPath);
    });

    const matchFn = file => fileMap.has(file);

    this.sourceFiles = Array.from(fileMap.keys()); // http://gotwarlost.github.io/istanbul/public/apidocs/classes/Hook.html#method_hookRequire.
    // Hook up to the Require function so that when this is called, if any of our source files
    // are required, the instrumented version is pulled in instead. These instrumented versions
    // write to a global coverage variable with hit counts whenever they are accessed.

    const transformer = this.instrumenter.instrumentSync.bind(this.instrumenter);
    const hookOpts = {
      verbose: false,
      extensions: ['.js']
    };
    istanbul.hook.hookRequire(matchFn, transformer, hookOpts); // Initialize the global variable to store instrumentation details.
    // http://gotwarlost.github.io/istanbul/public/apidocs/classes/Instrumenter.html.

    this.coverage = {}; // Hook the process exit event to handle reporting,
    // Only report coverage if the process is exiting successfully.

    process.on('exit', () => this.reportCoverage());
  }
  /**
   * Writes a coverage report. Note that as this is called in the process exit callback, all calls must be synchronous.
   * @returns {void}
   * @memberOf CoverageRunner
   */


  reportCoverage() {
    istanbul.hook.unhookRequire();
    const coverage = this.coverage; // Files that are not touched by code ran by the test runner is manually instrumented, to
    // illustrate the missing coverage.

    this.sourceFiles.filter(file => !coverage[file]).forEach(file => {
      this.instrumenter.instrumentSync(fs.readFileSync(file, 'utf-8'), file); // When instrumenting the code, istanbul will give each FunctionDeclaration a value of 1 in coverState.s,
      // presumably to compensate for function hoisting. We need to reset this, as the function was not hoisted,
      // as it was never loaded.

      Object.keys(this.instrumenter.coverState.s).forEach(key => this.instrumenter.coverState.s[key] = 0);
      coverage[file] = this.instrumenter.coverState;
    });
    const reportingDir = path.join(this.testsRoot, this.options.relativeCoverageDir);
    const coverageFile = path.join(reportingDir, 'coverage.json');
    fs.mkdirsSync(reportingDir);
    fs.writeFileSync(coverageFile, JSON.stringify(coverage), 'utf8');
    const remappedCollector = remapIstanbul.remap(coverage, {
      warn: warning => {
        // We expect some warnings as any JS file without a typescript mapping will cause this.
        // By default, we'll skip printing these to the console as it clutters it up.
        if (this.options.verbose) {
          console.warn(warning);
        }
      }
    });
    const reporter = new istanbul.Reporter(undefined, reportingDir);
    const reportTypes = Array.isArray(this.options.reports) ? this.options.reports : ['lcov'];
    reporter.addAll(reportTypes);
    reporter.write(remappedCollector, true, () => console.log(`reports written to ${reportingDir}`));
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3RSdW5uZXIuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmcyIsInJlcXVpcmUiLCJnbG9iIiwiaXN0YW5idWwiLCJNb2NoYSIsInBhdGgiLCJyZW1hcElzdGFuYnVsIiwicmVhY3RIZWxwZXJzXzEiLCJ0dHkiLCJnZXRXaW5kb3dTaXplIiwibW9jaGEiLCJ1aSIsInVzZUNvbG9ycyIsInRlc3RGaWxlc0dsb2IiLCJjb3ZlcmFnZU9wdGlvbnMiLCJjb25maWd1cmUiLCJzZXR1cE9wdGlvbnMiLCJjb3ZlcmFnZU9wdHMiLCJ0ZXN0RmlsZXNTdWZmaXgiLCJydW4iLCJ0ZXN0c1Jvb3QiLCJjYWxsYmFjayIsImluc3RhbGwiLCJzZXRVcERvbUVudmlyb25tZW50Iiwib3B0aW9ucyIsImdldENvdmVyYWdlT3B0aW9ucyIsImVuYWJsZWQiLCJjb3ZlcmFnZVJ1bm5lciIsIkNvdmVyYWdlUnVubmVyIiwic2V0dXBDb3ZlcmFnZSIsImlnbm9yZSIsImN3ZCIsImVycm9yIiwiZmlsZXMiLCJmb3JFYWNoIiwiZmlsZSIsImFkZEZpbGUiLCJqb2luIiwiZmFpbHVyZXMiLCJ1bmRlZmluZWQiLCJjb3ZlckNvbmZpZ1BhdGgiLCJjb3ZlcmFnZUNvbmZpZyIsImV4aXN0c1N5bmMiLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZVN5bmMiLCJjb25zdHJ1Y3RvciIsImVuZFJ1bkNhbGxiYWNrIiwiY292ZXJhZ2VWYXIiLCJEYXRlIiwiZ2V0VGltZSIsInNvdXJjZUZpbGVzIiwicmVsYXRpdmVTb3VyY2VQYXRoIiwiRXJyb3IiLCJjb3ZlcmFnZSIsImdsb2JhbCIsImtleXMiLCJsZW5ndGgiLCJjb25zb2xlIiwicmVwb3J0aW5nRGlyIiwicmVsYXRpdmVDb3ZlcmFnZURpciIsImVtcHR5RGlyU3luYyIsImluc3RydW1lbnRlciIsIkluc3RydW1lbnRlciIsImNvdmVyYWdlVmFyaWFibGUiLCJzb3VyY2VSb290Iiwic3JjRmlsZXMiLCJzeW5jIiwiaWdub3JlUGF0dGVybnMiLCJkZWNhY2hlIiwiZmlsZU1hcCIsIlNldCIsIm1hcCIsImZ1bGxQYXRoIiwiYWRkIiwibWF0Y2hGbiIsImhhcyIsIkFycmF5IiwiZnJvbSIsInRyYW5zZm9ybWVyIiwiaW5zdHJ1bWVudFN5bmMiLCJiaW5kIiwiaG9va09wdHMiLCJ2ZXJib3NlIiwiZXh0ZW5zaW9ucyIsImhvb2siLCJob29rUmVxdWlyZSIsInByb2Nlc3MiLCJvbiIsInJlcG9ydENvdmVyYWdlIiwidW5ob29rUmVxdWlyZSIsImZpbHRlciIsImNvdmVyU3RhdGUiLCJzIiwia2V5IiwiY292ZXJhZ2VGaWxlIiwibWtkaXJzU3luYyIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJyZW1hcHBlZENvbGxlY3RvciIsInJlbWFwIiwid2FybiIsIndhcm5pbmciLCJyZXBvcnRlciIsIlJlcG9ydGVyIiwicmVwb3J0VHlwZXMiLCJpc0FycmF5IiwicmVwb3J0cyIsImFkZEFsbCIsIndyaXRlIiwibG9nIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLEVBQUFBLEtBQUssRUFBRTtBQUFULENBQTdDOztBQUNBLE1BQU1DLEVBQUUsR0FBR0MsT0FBTyxDQUFDLFVBQUQsQ0FBbEI7O0FBQ0EsTUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxNQUFNRSxRQUFRLEdBQUdGLE9BQU8sQ0FBQyxVQUFELENBQXhCOztBQUNBLE1BQU1HLEtBQUssR0FBR0gsT0FBTyxDQUFDLE9BQUQsQ0FBckI7O0FBQ0EsTUFBTUksSUFBSSxHQUFHSixPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxNQUFNSyxhQUFhLEdBQUdMLE9BQU8sQ0FBQyxnQkFBRCxDQUE3Qjs7QUFDQSxNQUFNTSxjQUFjLEdBQUdOLE9BQU8sQ0FBQyw0QkFBRCxDQUE5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QUNLLE1BQVQsQ0FBZ0JILFdBQWhCO0FBQ0FGLElBQUFBLFFBQVEsQ0FBQ00sS0FBVCxDQUFlVixpQkFBZixFQUFrQyxJQUFsQyxFQUF3QyxNQUFNekMsT0FBTyxDQUFDb0QsR0FBUixDQUFhLHNCQUFxQm5ELFlBQWEsRUFBL0MsQ0FBOUM7QUFDSDs7QUEzR2dCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1yZXF1aXJlLWltcG9ydHMgbm8tdmFyLXJlcXVpcmVzIGltcG9ydC1uYW1lIG5vLWZ1bmN0aW9uLWV4cHJlc3Npb24gbm8tYW55IHByZWZlci10ZW1wbGF0ZSBuby1jb25zb2xlIG5vLXZhci1zZWxmXG4vLyBNb3N0IG9mIHRoZSBzb3VyY2UgaXMgaW4gbm9kZV9tb2R1bGVzL3ZzY29kZS9saWIvdGVzdHJ1bm5lci5qc1xuJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCBnbG9iID0gcmVxdWlyZShcImdsb2JcIik7XG5jb25zdCBpc3RhbmJ1bCA9IHJlcXVpcmUoXCJpc3RhbmJ1bFwiKTtcbmNvbnN0IE1vY2hhID0gcmVxdWlyZShcIm1vY2hhXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgcmVtYXBJc3RhbmJ1bCA9IHJlcXVpcmUoJ3JlbWFwLWlzdGFuYnVsJyk7XG5jb25zdCByZWFjdEhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2RhdGFzY2llbmNlL3JlYWN0SGVscGVyc1wiKTtcbi8vIExpbnV4OiBwcmV2ZW50IGEgd2VpcmQgTlBFIHdoZW4gbW9jaGEgb24gTGludXggcmVxdWlyZXMgdGhlIHdpbmRvdyBzaXplIGZyb20gdGhlIFRUWS5cbi8vIFNpbmNlIHdlIGFyZSBub3QgcnVubmluZyBpbiBhIHR0eSBlbnZpcm9ubWVudCwgd2UganVzdCBpbXBsZW1lbnQgdGhlIG1ldGhvZCBzdGF0aWNhbGx5LlxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5pZiAoIXR0eS5nZXRXaW5kb3dTaXplKSB7XG4gICAgdHR5LmdldFdpbmRvd1NpemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbODAsIDc1XTsgfTtcbn1cbmxldCBtb2NoYSA9IG5ldyBNb2NoYSh7XG4gICAgdWk6ICd0ZGQnLFxuICAgIHVzZUNvbG9yczogdHJ1ZVxufSk7XG5sZXQgdGVzdEZpbGVzR2xvYiA9ICd0ZXN0JztcbmxldCBjb3ZlcmFnZU9wdGlvbnM7XG5mdW5jdGlvbiBjb25maWd1cmUoc2V0dXBPcHRpb25zLCBjb3ZlcmFnZU9wdHMpIHtcbiAgICBpZiAoc2V0dXBPcHRpb25zLnRlc3RGaWxlc1N1ZmZpeCkge1xuICAgICAgICB0ZXN0RmlsZXNHbG9iID0gc2V0dXBPcHRpb25zLnRlc3RGaWxlc1N1ZmZpeDtcbiAgICB9XG4gICAgbW9jaGEgPSBuZXcgTW9jaGEoc2V0dXBPcHRpb25zKTtcbiAgICBjb3ZlcmFnZU9wdGlvbnMgPSBjb3ZlcmFnZU9wdHM7XG59XG5leHBvcnRzLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZTtcbmZ1bmN0aW9uIHJ1bih0ZXN0c1Jvb3QsIGNhbGxiYWNrKSB7XG4gICAgLy8gRW5hYmxlIHNvdXJjZSBtYXAgc3VwcG9ydC5cbiAgICByZXF1aXJlKCdzb3VyY2UtbWFwLXN1cHBvcnQnKS5pbnN0YWxsKCk7XG4gICAgLy8gbnRlcmFjdC90cmFuc2Zvcm1zLWZ1bGwgZXhwZWN0cyB0byBydW4gaW4gdGhlIGJyb3dzZXIgc28gd2UgaGF2ZSB0byBmYWtlXG4gICAgLy8gcGFydHMgb2YgdGhlIGJyb3dzZXIgaGVyZS5cbiAgICByZWFjdEhlbHBlcnNfMS5zZXRVcERvbUVudmlyb25tZW50KCk7XG4gICAgLy8gQ2hlY2sgd2hldGhlciBjb2RlIGNvdmVyYWdlIGlzIGVuYWJsZWQuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGdldENvdmVyYWdlT3B0aW9ucyh0ZXN0c1Jvb3QpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgICAvLyBTZXR1cCBjb3ZlcmFnZSBwcmUtdGVzdCwgaW5jbHVkaW5nIHBvc3QtdGVzdCBob29rIHRvIHJlcG9ydC5cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVzZS1iZWZvcmUtZGVjbGFyZVxuICAgICAgICBjb25zdCBjb3ZlcmFnZVJ1bm5lciA9IG5ldyBDb3ZlcmFnZVJ1bm5lcihvcHRpb25zLCB0ZXN0c1Jvb3QsIGNhbGxiYWNrKTtcbiAgICAgICAgY292ZXJhZ2VSdW5uZXIuc2V0dXBDb3ZlcmFnZSgpO1xuICAgIH1cbiAgICAvLyBSdW4gdGhlIHRlc3RzLlxuICAgIGdsb2IoYCoqLyoqLiR7dGVzdEZpbGVzR2xvYn0uanNgLCB7IGlnbm9yZTogWycqKi8qKi51bml0LnRlc3QuanMnLCAnKiovKiouZnVuY3Rpb25hbC50ZXN0LmpzJ10sIGN3ZDogdGVzdHNSb290IH0sIChlcnJvciwgZmlsZXMpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4gbW9jaGEuYWRkRmlsZShwYXRoLmpvaW4odGVzdHNSb290LCBmaWxlKSkpO1xuICAgICAgICAgICAgbW9jaGEucnVuKChmYWlsdXJlcykgPT4gY2FsbGJhY2sodW5kZWZpbmVkLCBmYWlsdXJlcykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5ydW4gPSBydW47XG5mdW5jdGlvbiBnZXRDb3ZlcmFnZU9wdGlvbnModGVzdHNSb290KSB7XG4gICAgaWYgKCFjb3ZlcmFnZU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY292ZXJDb25maWdQYXRoID0gcGF0aC5qb2luKHRlc3RzUm9vdCwgY292ZXJhZ2VPcHRpb25zLmNvdmVyYWdlQ29uZmlnKTtcbiAgICByZXR1cm4gZnMuZXhpc3RzU3luYyhjb3ZlckNvbmZpZ1BhdGgpID8gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoY292ZXJDb25maWdQYXRoLCAndXRmOCcpKSA6IHVuZGVmaW5lZDtcbn1cbmNsYXNzIENvdmVyYWdlUnVubmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCB0ZXN0c1Jvb3QsIGVuZFJ1bkNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudGVzdHNSb290ID0gdGVzdHNSb290O1xuICAgICAgICB0aGlzLmNvdmVyYWdlVmFyID0gYCQkY292XyR7bmV3IERhdGUoKS5nZXRUaW1lKCl9JCRgO1xuICAgICAgICB0aGlzLnNvdXJjZUZpbGVzID0gW107XG4gICAgICAgIGlmICghb3B0aW9ucy5yZWxhdGl2ZVNvdXJjZVBhdGgpIHtcbiAgICAgICAgICAgIGVuZFJ1bkNhbGxiYWNrKG5ldyBFcnJvcignRXJyb3IgLSByZWxhdGl2ZVNvdXJjZVBhdGggbXVzdCBiZSBkZWZpbmVkIGZvciBjb2RlIGNvdmVyYWdlIHRvIHdvcmsnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvdmVyYWdlKCkge1xuICAgICAgICBpZiAoZ2xvYmFsW3RoaXMuY292ZXJhZ2VWYXJdID09PSB1bmRlZmluZWQgfHwgT2JqZWN0LmtleXMoZ2xvYmFsW3RoaXMuY292ZXJhZ2VWYXJdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGNvdmVyYWdlIGluZm9ybWF0aW9uIHdhcyBjb2xsZWN0ZWQsIGV4aXQgd2l0aG91dCB3cml0aW5nIGNvdmVyYWdlIGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsW3RoaXMuY292ZXJhZ2VWYXJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBjb3ZlcmFnZSh2YWx1ZSkge1xuICAgICAgICBnbG9iYWxbdGhpcy5jb3ZlcmFnZVZhcl0gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5mb3JtYXRpb24gb24gaG9va2luZyB1cCBjb2RlIGNvdmVyYWdlIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgICAqIGh0dHA6Ly90YW5uZ3V5ZW4ub3JnLzIwMTcvMDQvZ3VscC1tb2NoYS1hbmQtaXN0YW5idWwvXG4gICAgICogaHR0cDovL2dvdHdhcmxvc3QuZ2l0aHViLmlvL2lzdGFuYnVsL3B1YmxpYy9hcGlkb2NzL2NsYXNzZXMvSG9va09wdGlvbnMuaHRtbFxuICAgICAqIEBtZW1iZXJvZiBDb3ZlcmFnZVJ1bm5lclxuICAgICAqL1xuICAgIHNldHVwQ292ZXJhZ2UoKSB7XG4gICAgICAgIGNvbnN0IHJlcG9ydGluZ0RpciA9IHBhdGguam9pbih0aGlzLnRlc3RzUm9vdCwgdGhpcy5vcHRpb25zLnJlbGF0aXZlQ292ZXJhZ2VEaXIpO1xuICAgICAgICBmcy5lbXB0eURpclN5bmMocmVwb3J0aW5nRGlyKTtcbiAgICAgICAgLy8gU2V0IHVwIENvZGUgQ292ZXJhZ2UsIGhvb2tpbmcgcmVxdWlyZSBzbyB0aGF0IGluc3RydW1lbnRlZCBjb2RlIGlzIHJldHVybmVkLlxuICAgICAgICB0aGlzLmluc3RydW1lbnRlciA9IG5ldyBpc3RhbmJ1bC5JbnN0cnVtZW50ZXIoeyBjb3ZlcmFnZVZhcmlhYmxlOiB0aGlzLmNvdmVyYWdlVmFyIH0pO1xuICAgICAgICBjb25zdCBzb3VyY2VSb290ID0gcGF0aC5qb2luKHRoaXMudGVzdHNSb290LCB0aGlzLm9wdGlvbnMucmVsYXRpdmVTb3VyY2VQYXRoKTtcbiAgICAgICAgLy8gR2xvYiBzb3VyY2UgZmlsZXNcbiAgICAgICAgY29uc3Qgc3JjRmlsZXMgPSBnbG9iLnN5bmMoJyoqLyoqLmpzJywge1xuICAgICAgICAgICAgaWdub3JlOiB0aGlzLm9wdGlvbnMuaWdub3JlUGF0dGVybnMsXG4gICAgICAgICAgICBjd2Q6IHNvdXJjZVJvb3RcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG1hdGNoIGZ1bmN0aW9uIC0gdGFrZW4gZnJvbSB0aGUgcnVuLXdpdGgtY292ZXIuanMgaW4gaXN0YW5idWwuXG4gICAgICAgIGNvbnN0IGRlY2FjaGUgPSByZXF1aXJlKCdkZWNhY2hlJyk7XG4gICAgICAgIGNvbnN0IGZpbGVNYXAgPSBuZXcgU2V0KCk7XG4gICAgICAgIHNyY0ZpbGVzXG4gICAgICAgICAgICAubWFwKGZpbGUgPT4gcGF0aC5qb2luKHNvdXJjZVJvb3QsIGZpbGUpKVxuICAgICAgICAgICAgLmZvckVhY2goZnVsbFBhdGggPT4ge1xuICAgICAgICAgICAgZmlsZU1hcC5hZGQoZnVsbFBhdGgpO1xuICAgICAgICAgICAgLy8gT24gV2luZG93cywgZXh0ZW5zaW9uIGlzIGxvYWRlZCBwcmUtdGVzdCBob29rcyBhbmQgdGhpcyBtZWFuIHdlIGxvc2VcbiAgICAgICAgICAgIC8vIG91ciBjaGFuY2UgdG8gaG9vayB0aGUgUmVxdWlyZSBjYWxsLiBJbiBvcmRlciB0byBpbnN0cnVtZW50IHRoZSBjb2RlXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGRlY2FjaGUgdGhlIEpTIGZpbGUgc28gb24gbmV4dCBsb2FkIGl0IGdldHMgaW5zdHJ1bWVudGVkLlxuICAgICAgICAgICAgLy8gVGhpcyBkb2Vzbid0IGltcGFjdCB0ZXN0cywgYnV0IGlzIGEgY29uY2VybiBpZiB3ZSBoYWQgc29tZSBpbnRlZ3JhdGlvblxuICAgICAgICAgICAgLy8gdGVzdHMgdGhhdCByZWxpZWQgb24gVlNDb2RlIGFjY2Vzc2luZyBvdXIgbW9kdWxlIHNpbmNlIHRoZXJlIGNvdWxkIGJlXG4gICAgICAgICAgICAvLyBzb21lIHNoYXJlZCBnbG9iYWwgc3RhdGUgdGhhdCB3ZSBsb3NlLlxuICAgICAgICAgICAgZGVjYWNoZShmdWxsUGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXRjaEZuID0gKGZpbGUpID0+IGZpbGVNYXAuaGFzKGZpbGUpO1xuICAgICAgICB0aGlzLnNvdXJjZUZpbGVzID0gQXJyYXkuZnJvbShmaWxlTWFwLmtleXMoKSk7XG4gICAgICAgIC8vIGh0dHA6Ly9nb3R3YXJsb3N0LmdpdGh1Yi5pby9pc3RhbmJ1bC9wdWJsaWMvYXBpZG9jcy9jbGFzc2VzL0hvb2suaHRtbCNtZXRob2RfaG9va1JlcXVpcmUuXG4gICAgICAgIC8vIEhvb2sgdXAgdG8gdGhlIFJlcXVpcmUgZnVuY3Rpb24gc28gdGhhdCB3aGVuIHRoaXMgaXMgY2FsbGVkLCBpZiBhbnkgb2Ygb3VyIHNvdXJjZSBmaWxlc1xuICAgICAgICAvLyBhcmUgcmVxdWlyZWQsIHRoZSBpbnN0cnVtZW50ZWQgdmVyc2lvbiBpcyBwdWxsZWQgaW4gaW5zdGVhZC4gVGhlc2UgaW5zdHJ1bWVudGVkIHZlcnNpb25zXG4gICAgICAgIC8vIHdyaXRlIHRvIGEgZ2xvYmFsIGNvdmVyYWdlIHZhcmlhYmxlIHdpdGggaGl0IGNvdW50cyB3aGVuZXZlciB0aGV5IGFyZSBhY2Nlc3NlZC5cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSB0aGlzLmluc3RydW1lbnRlci5pbnN0cnVtZW50U3luYy5iaW5kKHRoaXMuaW5zdHJ1bWVudGVyKTtcbiAgICAgICAgY29uc3QgaG9va09wdHMgPSB7IHZlcmJvc2U6IGZhbHNlLCBleHRlbnNpb25zOiBbJy5qcyddIH07XG4gICAgICAgIGlzdGFuYnVsLmhvb2suaG9va1JlcXVpcmUobWF0Y2hGbiwgdHJhbnNmb3JtZXIsIGhvb2tPcHRzKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZ2xvYmFsIHZhcmlhYmxlIHRvIHN0b3JlIGluc3RydW1lbnRhdGlvbiBkZXRhaWxzLlxuICAgICAgICAvLyBodHRwOi8vZ290d2FybG9zdC5naXRodWIuaW8vaXN0YW5idWwvcHVibGljL2FwaWRvY3MvY2xhc3Nlcy9JbnN0cnVtZW50ZXIuaHRtbC5cbiAgICAgICAgdGhpcy5jb3ZlcmFnZSA9IHt9O1xuICAgICAgICAvLyBIb29rIHRoZSBwcm9jZXNzIGV4aXQgZXZlbnQgdG8gaGFuZGxlIHJlcG9ydGluZyxcbiAgICAgICAgLy8gT25seSByZXBvcnQgY292ZXJhZ2UgaWYgdGhlIHByb2Nlc3MgaXMgZXhpdGluZyBzdWNjZXNzZnVsbHkuXG4gICAgICAgIHByb2Nlc3Mub24oJ2V4aXQnLCAoKSA9PiB0aGlzLnJlcG9ydENvdmVyYWdlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBjb3ZlcmFnZSByZXBvcnQuIE5vdGUgdGhhdCBhcyB0aGlzIGlzIGNhbGxlZCBpbiB0aGUgcHJvY2VzcyBleGl0IGNhbGxiYWNrLCBhbGwgY2FsbHMgbXVzdCBiZSBzeW5jaHJvbm91cy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKiBAbWVtYmVyT2YgQ292ZXJhZ2VSdW5uZXJcbiAgICAgKi9cbiAgICByZXBvcnRDb3ZlcmFnZSgpIHtcbiAgICAgICAgaXN0YW5idWwuaG9vay51bmhvb2tSZXF1aXJlKCk7XG4gICAgICAgIGNvbnN0IGNvdmVyYWdlID0gdGhpcy5jb3ZlcmFnZTtcbiAgICAgICAgLy8gRmlsZXMgdGhhdCBhcmUgbm90IHRvdWNoZWQgYnkgY29kZSByYW4gYnkgdGhlIHRlc3QgcnVubmVyIGlzIG1hbnVhbGx5IGluc3RydW1lbnRlZCwgdG9cbiAgICAgICAgLy8gaWxsdXN0cmF0ZSB0aGUgbWlzc2luZyBjb3ZlcmFnZS5cbiAgICAgICAgdGhpcy5zb3VyY2VGaWxlc1xuICAgICAgICAgICAgLmZpbHRlcihmaWxlID0+ICFjb3ZlcmFnZVtmaWxlXSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbnN0cnVtZW50ZXIuaW5zdHJ1bWVudFN5bmMoZnMucmVhZEZpbGVTeW5jKGZpbGUsICd1dGYtOCcpLCBmaWxlKTtcbiAgICAgICAgICAgIC8vIFdoZW4gaW5zdHJ1bWVudGluZyB0aGUgY29kZSwgaXN0YW5idWwgd2lsbCBnaXZlIGVhY2ggRnVuY3Rpb25EZWNsYXJhdGlvbiBhIHZhbHVlIG9mIDEgaW4gY292ZXJTdGF0ZS5zLFxuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSB0byBjb21wZW5zYXRlIGZvciBmdW5jdGlvbiBob2lzdGluZy4gV2UgbmVlZCB0byByZXNldCB0aGlzLCBhcyB0aGUgZnVuY3Rpb24gd2FzIG5vdCBob2lzdGVkLFxuICAgICAgICAgICAgLy8gYXMgaXQgd2FzIG5ldmVyIGxvYWRlZC5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuaW5zdHJ1bWVudGVyLmNvdmVyU3RhdGUucykuZm9yRWFjaChrZXkgPT4gdGhpcy5pbnN0cnVtZW50ZXIuY292ZXJTdGF0ZS5zW2tleV0gPSAwKTtcbiAgICAgICAgICAgIGNvdmVyYWdlW2ZpbGVdID0gdGhpcy5pbnN0cnVtZW50ZXIuY292ZXJTdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcG9ydGluZ0RpciA9IHBhdGguam9pbih0aGlzLnRlc3RzUm9vdCwgdGhpcy5vcHRpb25zLnJlbGF0aXZlQ292ZXJhZ2VEaXIpO1xuICAgICAgICBjb25zdCBjb3ZlcmFnZUZpbGUgPSBwYXRoLmpvaW4ocmVwb3J0aW5nRGlyLCAnY292ZXJhZ2UuanNvbicpO1xuICAgICAgICBmcy5ta2RpcnNTeW5jKHJlcG9ydGluZ0Rpcik7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoY292ZXJhZ2VGaWxlLCBKU09OLnN0cmluZ2lmeShjb3ZlcmFnZSksICd1dGY4Jyk7XG4gICAgICAgIGNvbnN0IHJlbWFwcGVkQ29sbGVjdG9yID0gcmVtYXBJc3RhbmJ1bC5yZW1hcChjb3ZlcmFnZSwge1xuICAgICAgICAgICAgd2Fybjogd2FybmluZyA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZXhwZWN0IHNvbWUgd2FybmluZ3MgYXMgYW55IEpTIGZpbGUgd2l0aG91dCBhIHR5cGVzY3JpcHQgbWFwcGluZyB3aWxsIGNhdXNlIHRoaXMuXG4gICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2UnbGwgc2tpcCBwcmludGluZyB0aGVzZSB0byB0aGUgY29uc29sZSBhcyBpdCBjbHV0dGVycyBpdCB1cC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcG9ydGVyID0gbmV3IGlzdGFuYnVsLlJlcG9ydGVyKHVuZGVmaW5lZCwgcmVwb3J0aW5nRGlyKTtcbiAgICAgICAgY29uc3QgcmVwb3J0VHlwZXMgPSBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5yZXBvcnRzKSA/IHRoaXMub3B0aW9ucy5yZXBvcnRzIDogWydsY292J107XG4gICAgICAgIHJlcG9ydGVyLmFkZEFsbChyZXBvcnRUeXBlcyk7XG4gICAgICAgIHJlcG9ydGVyLndyaXRlKHJlbWFwcGVkQ29sbGVjdG9yLCB0cnVlLCAoKSA9PiBjb25zb2xlLmxvZyhgcmVwb3J0cyB3cml0dGVuIHRvICR7cmVwb3J0aW5nRGlyfWApKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXN0UnVubmVyLmpzLm1hcCJdfQ==